#!/bin/bash

####################
# Engine Variables #
####################

engine_state="loading program"
engine_interactive=1 #enabled or disables the debugging REPL
engine_no_process_depth=0 #how deeply nested in a failing if statement are we?

####################
# Global Variables #
####################

#Set defaults
declare -A globals=( ["UDPComment"]="#" )

#############
# Functions #
#############

help() {
  echo 'Command Help'
}

#$1 line to check
#$2 regex to match comment
is_comment() {
  local regex="##.*$2"
  [[ $1 =~ $regex ]]
}

#$1 line to read
#$2 target
#$3 target preamble
read_line() {
  local raw_regex="$2=(.+)$"
  local regex="$3$raw_regex"
  local comment_regex="(?:$3)?$raw_regex"
  if ! (is_comment "$1" "$comment_regex") && [[ $1 =~ $regex ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

#$1 line to check for globals
read_globals() {
  for global in "${!globals[@]}"; do
    if out=$(read_line "$1" "$global" "#"); then
      globals[$global]=$out
    fi
  done
}

###############
# Debug State #
###############

echo_globals() {
  for global in "${!globals[@]}"; do
    echo "Global \"$global\"=\"${globals[$global]}\""
  done
}

echo_processor_state() {
}

echo_engine() {
  echo "Engine State: $engine_state"
  if [[ $engine_interactive -eq 0 ]]; then
    echo "Engine in non-interactive mode. REPL unavailable"
  else
    echo "Engine in interactive mode. REPL available"
  fi
  echo "Engine no process depth=$engine_no_process_depth"
}

debug_state() {
  echo_engine
  echo "Dumping Globals"
  echo_globals
  echo "Dumping Processor State"
  echo_processor_state
}

help_udp() {
  echo "Variables"
  echo
  echo "engine_state - String. Stores current engine state"
  echo "engine_interactive - 0/1. Stores if a REPL can be safely started"
  echo "engine_no_process_depth - Numeric. Stores how deeply nested into a failing if we are"
  echo "globals - Bash Associative Array. Stores all global variables"
  echo
  echo "Debugging Functions"
  echo
  echo "help_udp - display this help prompt"
  echo "debug_state - dumps entire process state"
  echo "echo_engine - dumps current engine information"
  echo "echo_globals - dumps all set global variables"
  echo "echo_processor_state - dumps all pre/postprocessor variables"
  echo
  echo "exit - exit interactive debugging"
}

debug_repl() {
  if [[ $engine_interactive -ne 1 ]]; then
    echo "Interactive debugging not available during engine state \"$engine_state\""
  else
    echo "Entering interactive debugging"
    echo
    help_udp
    echo
    while true; do
      read -rp "UDP$ " command
      if [[ $command =~ "exit" ]]; then
        echo "Exiting prompt"
        return 0
      fi
      eval "$command"
    done
  fi
}

#$1 line to check for debug statements
debug_line() {
  local regex="#\\?(..)\\?# ?(.*)"
  if ! is_comment "$1" "$regex" && [[ $1 =~ $regex ]]; then
    if [[ $engine_no_process_depth -ne 0 ]]; then
      echo "Debugging inside failed if statement!"
    fi
    case ${BASH_REMATCH[1]} in
      'DS')
        debug_state
        ;;
      'DG')
        echo "Dumping Globals"
        echo_globals
        ;;
      'DP')
        echo "Dumping Processor State"
        echo_processor_state
        ;;
      'DI')
        debug_repl
        ;;
      'DE')
        echo_engine
        ;;
      'DM')
        echo "Reached Mark ${BASH_REMATCH[2]} while in engine_state $engine_state"
        ;;
      *)
        echo "Unknown debug option \"${BASH_REMATCH[1]}\""
        ;;
    esac
  fi
}

###############
# Early Exits #
###############

# Invalid command early exit
if [[ $# -eq 0 ]]; then
  echo 'To few arguments'
  help
  exit 10
fi

# Invalid file early exit
if [[ ! -f $1 ]]; then
  echo "file \"$1\" does not exist"
  exit 12
fi

################
# Load file in #
################

echo "Loading \"$1\""

file=()

# This will load in the file line by line while looking for global variables

engine_state="load file"
engine_interactive=0
while IFS= read -r line
do
  file+=("$line")
  debug_line "$line"
done < "$1"


###################
# Load globals in #
###################

engine_state="load globals"
engine_interactive=1
for line in "${file[@]}"; do
  read_globals "$line"
  debug_line "$line"
done
